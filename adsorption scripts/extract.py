#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created Oct 2025
PURPOSE:
Processes raw data spread across multiple directories after GDS analysis
Compiles them into a single compressed .npz file.
Step 1 in data post-processing and analysis pipeline.

INPUT:
    - frame.txt
    - subdirectories named as integers (e.g., 1, 2, 3, ...)
each subdirectory should contain:
    folder counts
    folder density
    folder molfrac
    folder raw
    wc_surface_area.txt
    sum_dimensions_0*.txt
    sum_proximity_0*.txt

OUTPUT:
    - rawdata.npz
    - avgs_og.txt
    - avgs.png
    - element_counts.png
    - Ne_counts.png
    - Ne_phase.png
    - Ne_prox.png

Note:
Due to the extended nature of Ne distribution across the ferropericlase side of the interfacial region,
the Ne counts and phase allocations are adjusted to account for Ne atoms within 5 Angstroms of the interface
plane, on the ferropericlase side only (instead of width set by nw during GDS analysis. See plots generated by frac.py,
in folders labeled "4-frac").
Set variable solid_int for new cutoff proximity value.
"""

import numpy as np
import os
import argparse
import glob
import matplotlib.pyplot as plt

parser = argparse.ArgumentParser()
parser.add_argument("--path", "-p", type=str, default='./', help="Path to the directories")

args = parser.parse_args()
path = args.path

# list of folders that the raw data is split across
subdirs = [d for d in os.listdir(path) if os.path.isdir(os.path.join(path, d))]
int_dirs = []
for subdir in subdirs:
    if subdir.isdigit():
        int_dirs.append(int(subdir))
int_dirs.sort()
if len(int_dirs) == 0:
    print("No directories found")
    exit()

# text file containing start frame and end frame of the portion of the trajectory analyzed
frame_file = os.path.join(path, "frame.txt")
if not os.path.isfile(frame_file):
    print(f"File {frame_file} not found")
    exit()

start_frame = 0
end_frame = 0
with open(frame_file, "r") as f:
    lines = [line.strip() for line in f if line.strip()]
    start_frame = int(lines[0])
    end_frame = int(lines[1])

# data organization and storage into lists
# avoiding dictionaries for now to keep the information straightforward
wc = [] # one value per frame
box = []
lw = []
chi = []

O = [] # takes form [liquid, solid, interface] per frame
Ne = []
Mg = []
Fe = []

prox = [] # one array of proximity axis coordinates for each frame
density = [] # one array of values following the unique proximity axis for each frame
count_Mg = [] # ''
count_O = []
count_Fe = []
count_Ne = []
frac_Mg = []
frac_O = []
frac_Fe = []
frac_Ne = []

atom_type = [] # atom ID and type ordering, identical across all frames and consistent with merge.xyz or selected.dump 
atom_prox = [] # atom locations along proximity axis for each frame
atom_phase = [] # 2 is liquid, 1 is solid, 0 is interface (label for every atom in each frame)

chi_filter = [] # frames with chi < 0.1


# atom_type
atom_order = np.loadtxt(os.path.join(path, str(1), "raw", str(0) + '_raw.txt'), dtype=str, comments="#", unpack=True, usecols=(0))
for atom in atom_order:
    if atom=='Mg':
        atom_type.append(0)
    elif atom=='O':
        atom_type.append(1)
    elif atom=='Fe':
        atom_type.append(2)
    elif atom=='Ne':
        atom_type.append(3)


for i in int_dirs:
    # wc
    sa = np.loadtxt(os.path.join(path, str(i), "wc_surface_area.txt"), dtype=float, comments="#", usecols=1, ndmin=1)
    wc.extend(sa.tolist())

    # box
    files = glob.glob(os.path.join(path, str(i), 'sum_dimensions_0*'))
    L = np.loadtxt(files[0], dtype=float, comments="#", usecols=(4,5,6))
    # O, Ne, Mg, Fe, lw, chi
    files = glob.glob(os.path.join(path, str(i), 'sum_proximity_0*'))
    p = np.loadtxt(files[0], dtype=float, comments="#", usecols=range(1, 15))
    if L.ndim==1:
        box.append(L)
        O.append(p[:3])
        Ne.append(p[3:6])
        Mg.append(p[6:9])
        Fe.append(p[9:12])
        lw.append(p[12])
        chi.append(p[13])
    else:
        for row in L:
            box.append(row)
        for row in p:
            O.append(row[:3])
            Ne.append(row[3:6])
            Mg.append(row[6:9])
            Fe.append(row[9:12])
            lw.append(row[12])
            chi.append(row[13])
            
    # prox, density, molfrac, counts, atom_prox, atom_phase      
    total_idx = len(sa)
    for idx in range(total_idx):
        pr, d = np.loadtxt(os.path.join(path, str(i), "density", str(idx)+'_prox.txt'), dtype=float, comments="#", unpack=True, usecols=(0,1))
        mg_f, o_f, fe_f, ne_f = np.loadtxt(os.path.join(path, str(i), "molfrac", str(idx)+'_atomic_fraction.txt'), dtype=float, comments="#", unpack=True, usecols=(1,3,5,7))
        mg_c, o_c, fe_c, ne_c = np.loadtxt(os.path.join(path, str(i), "counts", str(idx)+'_prox_counts.txt'), dtype=float, comments="#", unpack=True, usecols=(1,2,3,4))
        pos, ph = np.loadtxt(os.path.join(path, str(i) , "raw", str(idx)+'_raw.txt'), dtype=float, comments="#", unpack=True, usecols=(1,2))
        prox.append(pr)
        density.append(d)
        frac_Mg.append(mg_f)
        frac_O.append(o_f)
        frac_Fe.append(fe_f)
        frac_Ne.append(ne_f)
        count_Mg.append(mg_c.astype(int))
        count_O.append(o_c.astype(int))
        count_Fe.append(fe_c.astype(int))
        count_Ne.append(ne_c.astype(int))
        atom_prox.append(pos)
        atom_phase.append(ph.astype(int))


# extracting atom IDs for Ne
Ne_i = np.where(np.array(atom_type)==3)[0]
# new proximity cutoff for Ne atoms to be considered in solid phase
solid_int = -5

for i in range(len(chi)):
    if chi[i] < 0.1:
        chi_filter.append(i)
    
    # To reassign the phase a Ne atom belongs to, Ne phase counts need to be adjusted. All other info same
    count_i = 0 # number of Ne atoms (in current frame i) switched from solid to interface
    for j in Ne_i:
        if (atom_prox[i][j] > solid_int) and (atom_prox[i][j] < 0) and (atom_phase[i][j] == 1):
            count_i += 1
            atom_phase[i][j] = 0 # 1 is solid, 0 is interface
    Ne[i][1] -=count_i # array Ne takes form [liquid, solid, interface] per frame
    Ne[i][2] += count_i


# double check that correct number of frames processed as intended
if len(wc) == (end_frame-start_frame)/500+1:
    print("All frames processed")
else:
    print(f"Only {len(wc)} frames processed, expected {(end_frame-start_frame)/500+1}")
    exit()

# arrays to be padded to ensure consistent number of coordinates across all frames (to avoid errors later)
arr_list = [prox, density, count_Mg, count_O, count_Fe, count_Ne, frac_Mg, frac_O, frac_Fe, frac_Ne]
max_len = max(len(arr) for arr in arr_list[0])
pad_frame = []
for i in range(len(arr_list[0])):
    if len(arr_list[0][i]) < max_len:
        pad_frame.append(i) # records frames that need padding to enforce consistent array lengths

# applying padding
for arr in arr_list:
    for i in pad_frame:
        if arr[i].dtype == int: 
            # arrays in arr_list that are integer counts (count_*)
            arr[i] = np.pad(arr[i], (0, max_len - len(arr[i])), mode='constant', constant_values=-1)
        else:
            # arrays in arr_list that are float values (prox, density, frac_*)
            arr[i] = np.pad(arr[i], (0, max_len - len(arr[i])), mode='constant', constant_values=np.nan)


# save all data to compressed npz file
np.savez_compressed(os.path.join(path,"rawdata.npz"), wc=wc, box=box, lw=lw, chi=chi, O=O, Ne=Ne, Mg=Mg, Fe=Fe,
                   prox=prox, density=density, count_Mg=count_Mg, count_O=count_O,
                   count_Fe=count_Fe, count_Ne=count_Ne, frac_Mg=frac_Mg, frac_O=frac_O,
                   frac_Fe=frac_Fe, frac_Ne=frac_Ne, atom_type=atom_type, atom_prox=atom_prox,
                   atom_phase=atom_phase, chi_filter=chi_filter)


# some basic averages
with open(os.path.join(path, "avgs_og.txt"), "w") as file:
    file.write(f"Willard-Chandler surface area: {np.mean(np.array(wc))}\n")
    V = np.array(box)[:,0]*np.array(box)[:,1]*np.array(box)[:,2]
    file.write(f"Box volume: {np.mean(V)}\n")
    file.write(f"lw: {np.mean(np.array(lw))}\n")
    file.write(f"chi: {np.mean(np.array(chi))}\n")
    O_avg = np.mean(np.array(O), axis=0)
    Ne_avg = np.mean(np.array(Ne), axis=0)
    Mg_avg = np.mean(np.array(Mg), axis=0)
    Fe_avg = np.mean(np.array(Fe), axis=0)
    file.write(f"O (liquid, solid, interface): {O_avg[0],O_avg[1],O_avg[2]}\n")
    file.write(f"Ne (liquid, solid, interface): {Ne_avg[0],Ne_avg[1],Ne_avg[2]}\n")
    file.write(f"Mg (liquid, solid, interface): {Mg_avg[0],Mg_avg[1],Mg_avg[2]}\n")
    file.write(f"Fe (liquid, solid, interface): {Fe_avg[0],Fe_avg[1],Fe_avg[2]}\n")
    file.write(f"Frames with chi > 0.1: {len(chi)-len(chi_filter)}\n")
print("Averages written to avgs_og.txt")


# some basic plots
time = np.array(range(len(wc)))+start_frame/500

# time evolution of wc, box, lw, chi
fig, axs = plt.subplots(2, 2, figsize=(12, 8))
axs = axs.flatten()
axs[0].plot(time, wc)
axs[0].set_ylabel('Willard-Chandler Surface Area')
axs[0].set_xlabel('Frame Index')
axs[1].plot(time, V)
axs[1].set_ylabel('Box Volume')
axs[1].set_xlabel('Frame Index')
axs[2].plot(time, lw)
axs[2].set_ylabel('lw')
axs[2].set_xlabel('Frame Index')
axs[3].plot(time, chi)
axs[3].set_ylabel('chi')
axs[3].set_xlabel('Frame Index')
plt.tight_layout()
plt.savefig(os.path.join(path, "avgs.png"))
plt.close()

# time evolution of O, Ne, Mg, Fe counts
fig, axs = plt.subplots(2, 2, figsize=(12, 8))
axs = axs.flatten()
axs[0].plot(time, np.array(O)[:,0], label='liquid')
axs[0].plot(time, np.array(O)[:,1], label='solid')
axs[0].plot(time, np.array(O)[:,2], label='interface')
axs[0].set_ylabel('O counts')
axs[0].set_xlabel('Frame Index')
axs[0].legend()
axs[1].plot(time, np.array(Ne)[:,0], label='liquid')
axs[1].plot(time, np.array(Ne)[:,1], label='solid')
axs[1].plot(time, np.array(Ne)[:,2], label='interface')
axs[1].set_ylabel('Ne counts')
axs[1].set_xlabel('Frame Index')
axs[1].legend()
axs[2].plot(time, np.array(Mg)[:,0], label='liquid')
axs[2].plot(time, np.array(Mg)[:,1], label='solid')
axs[2].plot(time, np.array(Mg)[:,2], label='interface')
axs[2].set_ylabel('Mg counts')
axs[2].set_xlabel('Frame Index')
axs[2].legend()
axs[3].plot(time, np.array(Fe)[:,0], label='liquid')
axs[3].plot(time, np.array(Fe)[:,1], label='solid')
axs[3].plot(time, np.array(Fe)[:,2], label='interface')
axs[3].set_ylabel('Fe counts')
axs[3].set_xlabel('Frame Index')
axs[3].legend()
plt.tight_layout()
plt.savefig(os.path.join(path, "element_counts.png"))
plt.close()


# Ne specific plots
# time evolution of Ne counts in each of the three phases
fig, axs = plt.subplots(3, 1, figsize=(8, 10))
axs = axs.flatten()
axs[0].plot(range(len(Ne)), np.array(Ne)[:,0], label='liquid', alpha=0.8)
axs[1].plot(range(len(Ne)), np.array(Ne)[:,1], label='solid', alpha=0.8)
axs[2].plot(range(len(Ne)), np.array(Ne)[:,2], label='interface', alpha=0.8)
axs[0].set_ylabel('Ne counts in liquid')
axs[0].set_xlabel('Frame Index')
axs[1].set_ylabel('Ne counts in solid')
axs[1].set_xlabel('Frame Index')
axs[2].set_ylabel('Ne counts in interface')
axs[2].set_xlabel('Frame Index')
plt.tight_layout()
plt.savefig(os.path.join(path, "Ne_counts.png"))
plt.close()

# time evolution of phase occupancy for each Ne atom
plt.figure(figsize=(10, 6))
for i in range(len(atom_type)):
    if atom_type[i]==3: # Ne
        phase = []
        for j in range(len(wc)):
            if atom_phase[j][i] == 2:
                phase.append(1)
            elif atom_phase[j][i] == 1:
                phase.append(-1)
            else:
                phase.append(atom_phase[j][i])
        plt.plot(time, phase, alpha=0.8)
plt.ylabel('Atom Phase (-1: solid, 0: interface, 1: liquid)')
plt.xlabel('Frame Index')
plt.tight_layout()
plt.savefig(os.path.join(path, "Ne_phase.png"))
plt.close()

# time evolution of position along proximity axis for each Ne atom
plt.figure(figsize=(10, 6))
for i in range(len(atom_type)):
    if atom_type[i]==3: # Ne
        plt.plot(time, np.array(atom_prox)[:,i],alpha=0.8)
plt.ylabel('Atom Proximity')
plt.xlabel('Frame Index')
plt.tight_layout()
plt.savefig(os.path.join(path, "Ne_prox.png"))
plt.close()

